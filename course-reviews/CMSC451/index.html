<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
  <head>
    <meta charset="utf-8">
    <title>CMSC451 Review</title>
    <link rel="stylesheet" href="../../style.css">
    <link rel="stylesheet" href="../../Computer Modern/Serif/cmun-serif.css">
  </head>
  <body>
    <nav>
      <ul class="navList">
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../../resume.pdf">Resume</a></li>
      </ul>
      <div class="overlayMenuButton">
        <div class="line1"></div>
        <div class="line2"></div>
        <div class="line3"></div>
      </div>
    </nav>
    <script src="../../nav.js"></script>
    <div>
      <h2>CMSC451 Design and Analysis of Computer Algorithms</h2>
        <h3>What does it say on Testudo?</h3>
        Fundamental techniques for designing efficient computer algorithms, proving their correctness, and analyzing their complexity. General topics include graph algorithms, basic algorithm design paradigms (such as greedy algorithms, divide-and-conquer, and dynamic programming), network flows, NP-completeness, and other selected topics in algorithms.
        <h3>Why did I take this class?? Should I have taken this class???</h3>
        Definitely a very interesting and useful class. I would have taken this eventually, but I think the online format for this class is suboptimal.
        Probably more valuable in-person.
        <h3>Review</h3>
        I learned a lot of useful algorithm patterns, but some of the algorithms seem so niche that they're just for fun.
        We covered all of the topics in the description and syllabus.
        The full list:
        <ul>
          <li>Introduction and mathematical background</li>
          <li>Graph algorithms: connectivity, bipartiteness, topological sorting</li>
          <li>Greedy algorithms: shortest paths, minimum spanning trees, scheduling</li>
          <li>Divide-and-conquer algorithms: mergesort, closest points, integer multiplication</li>
          <li>Dynamic programming: weighted interval scheduling, knapsack, sequence alignment, shortest paths</li>
          <li>Network flows: Ford-Fulkerson algorithm, applications</li>
          <li>NP-completeness: P and NP, reductions, the Cook-Levin theorem</li>
          <li>Approximation algorithms: load balancing, set cover</li>
          <li>Randomized algorithms: minimum cut, game tree evaluation</li>
          <li>Quantum algorithms: quantum circuits, Deutschâ€™s problem</li>
        </ul>
        The first half of the class up to the midterm (before dynamic programming) was pretty easy.
        The only thing is that the proofs of correctness tend to be extremely handwavy.
        I think the TAs didn't really take grading seriously since the averages on the homeworks and midterm were very high.
        For the second half of the class, I stopped attending live lectures since they were basically like office hours.
        
    </div>
  </body>
</html>
